{
  boolean isTimeout=false;
  long currentTime=System.currentTimeMillis();
  LOG.debug("Checking delivery timeout using time {}",currentTime);
  for (  Map.Entry<Integer,Long> logRequest : timeoutMap.entrySet()) {
    LOG.info("processing timeoutMap pair: {}, {}",logRequest.getKey(),logRequest.getValue());
    if (currentTime >= logRequest.getValue()) {
      isTimeout=true;
      break;
    }
  }
  if (isTimeout) {
    LOG.info("Log delivery timeout detected. Processing timeout map with {} keys",timeoutMap.size());
    List<Integer> toRemove=new ArrayList<Integer>();
    for (    Map.Entry<Integer,Long> logRequest : timeoutMap.entrySet()) {
      storage.notifyUploadFailed(logRequest.getKey());
      toRemove.add(logRequest.getKey());
    }
    for (    Integer key : toRemove) {
      LOG.info("Removing following key from timeoutMap: {}",key);
      timeoutMap.remove(key);
    }
    final LogFailoverCommand controller=this.controller;
    executorContext.getCallbackExecutor().execute(new Runnable(){
      @Override public void run(){
        strategy.onTimeout(controller);
      }
    }
);
  }
  return isTimeout;
}
