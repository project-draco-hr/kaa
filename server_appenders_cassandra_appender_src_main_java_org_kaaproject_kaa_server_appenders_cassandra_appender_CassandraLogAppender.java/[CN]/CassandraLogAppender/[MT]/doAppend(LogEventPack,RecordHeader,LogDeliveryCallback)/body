{
  if (!closed) {
    try {
      LOG.debug("[{}] appending {} logs to cassandra collection",tableName,logEventPack.getEvents().size());
      GenericAvroConverter<GenericRecord> eventConverter=getConverter(logEventPack.getLogSchema().getSchema());
      GenericAvroConverter<GenericRecord> headerConverter=getConverter(header.getSchema().toString());
      List<CassandraLogEventDto> dtoList=generateCassandraLogEvent(logEventPack,header,eventConverter);
      LOG.debug("[{}] saving {} objects",tableName,dtoList.size());
      if (!dtoList.isEmpty()) {
switch (executeRequestType) {
case ASYNC:
          ListenableFuture<ResultSet> result=logEventDao.saveAsync(dtoList,tableName,eventConverter,headerConverter);
        Futures.addCallback(result,new Callback(listener),callbackExecutor);
      break;
case SYNC:
    logEventDao.save(dtoList,tableName,eventConverter,headerConverter);
  listener.onSuccess();
break;
}
LOG.debug("[{}] appended {} logs to cassandra collection",tableName,logEventPack.getEvents().size());
}
 else {
listener.onInternalError();
}
}
 catch (IOException e) {
LOG.warn("Got io exception. Can't generate log events",e);
listener.onInternalError();
}
catch (RuntimeException e) {
LOG.warn("Appender got runtime exception:",e);
listener.onInternalError();
}
}
 else {
LOG.info("Attempted to append to closed appender named [{}].",getName());
listener.onConnectionError();
}
}
