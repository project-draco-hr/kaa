{
  FailoverDecision decision=failoverManager.onFailover(status);
switch (decision.getAction()) {
case NOOP:
    LOG.warn("No operation is performed according to failover strategy decision");
  break;
case RETRY:
long retryPeriod=decision.getRetryPeriod();
LOG.warn("Attempt to receive operations server list will be made in {} ms, " + "according to failover strategy decision",retryPeriod);
executorContext.getScheduledExecutor().schedule(new Runnable(){
@Override public void run(){
try {
  receiveOperationsServerList();
}
 catch (TransportException e) {
  LOG.error("Error while receiving operations server list",e);
}
}
}
,retryPeriod,TimeUnit.MILLISECONDS);
break;
case USE_NEXT_BOOTSTRAP:
LOG.warn("Trying to switch to the next bootstrap server according to failover strategy decision");
retryPeriod=decision.getRetryPeriod();
failoverManager.onServerFailed(channelManager.getActiveServer(TransportType.BOOTSTRAP),status);
executorContext.getScheduledExecutor().schedule(new Runnable(){
@Override public void run(){
try {
receiveOperationsServerList();
}
 catch (TransportException e) {
LOG.error("Error while receiving operations server list",e);
}
}
}
,retryPeriod,TimeUnit.MILLISECONDS);
break;
case STOP_APP:
LOG.warn("Stopping application according to failover strategy decision!");
System.exit(EXIT_FAILURE);
break;
default :
break;
}
}
