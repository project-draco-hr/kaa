{
  LOG.debug("Got move request to [{}]",cell);
  targetCell=cell;
  targetCellApproved=false;
  final List<String> keys=new ArrayList<>(robotPositions.keySet());
  int robotCount=keys.size();
  if (robotCount > 0) {
    moveRequestLatch=new CountDownLatch(robotCount);
    moveRequestId=UUID.randomUUID().toString();
    moveRequestResponses=new HashSet<Boolean>(robotCount);
synchronized (conflictLock) {
      moveRequestConflict=false;
    }
    LOG.debug("Send move request {} to {} robots",moveRequestId,robotCount);
    eventExecutor.submit(new Runnable(){
      @Override public void run(){
        MovementRequest request=new MovementRequest(moveRequestId,cellToLocation(targetCell));
        for (        String key : keys) {
          family.sendEvent(request,key);
        }
      }
    }
);
    try {
      if (moveRequestLatch.await(PROCESSING_TIME_OUT,TimeUnit.MILLISECONDS)) {
        boolean allowed=analyzeResponses();
        if (allowed) {
          targetCellApproved=true;
          LOG.debug("Move allowed for request {}",moveRequestId);
          moveAllowed(moveListener);
        }
 else {
          LOG.debug("Move forbidden for request {}",moveRequestId);
          moveForbidden(moveListener,Reason.CONFLICT);
        }
      }
 else {
        LOG.debug("Received timeout while waiting responses for move request {}",moveRequestId);
        moveForbidden(moveListener,Reason.TIMEOUT);
      }
      ;
    }
 catch (    InterruptedException e) {
      LOG.debug("Received error while waiting responses for move request {}",moveRequestId);
      moveForbidden(moveListener,Reason.ERROR);
    }
  }
 else {
    LOG.debug("There is no other robots, so, move request is allowed!");
    moveAllowed(moveListener);
  }
}
