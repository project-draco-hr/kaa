{
  final View rootView=inflater.inflate(R.layout.fragment_dashboard,container,false);
  endpoint=new FakeDataEndpoint();
  gaugeCharts.add((GaugeChart)rootView.findViewById(R.id.gaugeChart11));
  gaugeCharts.add((GaugeChart)rootView.findViewById(R.id.gaugeChart12));
  gaugeCharts.add((GaugeChart)rootView.findViewById(R.id.gaugeChart13));
  gaugeCharts.add((GaugeChart)rootView.findViewById(R.id.gaugeChart21));
  gaugeCharts.add((GaugeChart)rootView.findViewById(R.id.gaugeChart22));
  gaugeCharts.add((GaugeChart)rootView.findViewById(R.id.gaugeChart23));
  logBox=(TextView)rootView.findViewById(R.id.logBox);
  logBox.setMovementMethod(new ScrollingMovementMethod());
  Thread updateThread=new Thread(new Runnable(){
    @Override public void run(){
      Log.i(TAG,"generating history data ");
      final List<DataReport> reports=endpoint.getHistoryData(0);
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          Log.i(TAG,"populating charts with data " + reports.size());
          prepareLineChart(rootView,reports);
          Log.i(TAG,"populated line chart with data ");
          preparePieChart(rootView,reports.get(reports.size() - 1));
          Log.i(TAG,"populated pie chart with data ");
        }
      }
);
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException e1) {
        e1.printStackTrace();
      }
      DataReport previousReport=reports.get(reports.size() - 1);
      long previousUpdate=0l;
      while (true) {
        boolean updated=false;
        while (!updated) {
          try {
            Thread.sleep(UPDATE_CHECK_PERIOD);
            if (System.currentTimeMillis() - previousUpdate < UPDATE_PERIOD) {
              continue;
            }
            DataReport latestDataCandidate=endpoint.getLatestData();
            if (latestDataCandidate.getTime() > previousReport.getTime()) {
              previousReport=latestDataCandidate;
              updated=true;
              previousUpdate=System.currentTimeMillis();
            }
          }
 catch (          InterruptedException e) {
            Log.e(TAG,"Failed to fetch data",e);
          }
        }
        final DataReport latestData=previousReport;
        mActivity.runOnUiThread(new Runnable(){
          @Override public void run(){
            float maxValue=Float.MIN_VALUE;
            float minValue=Float.MAX_VALUE;
            PieChartData data=pieChart.getPieChartData();
            float plantVoltage=0.0f;
            int counter=0;
            for (            DataPoint dp : latestData.getDataPoints()) {
              plantVoltage+=dp.getVoltage();
              SliceValue sliceValue=data.getValues().get(dp.getPanelId());
              sliceValue.setTarget(dp.getVoltage());
              gaugeCharts.get(counter).setValue(dp.getVoltage());
              showLogIfNeeded(counter,dp.getVoltage());
              counter++;
            }
            float gridVoltage=latestData.getPowerConsumption() - plantVoltage;
            pieChart.startDataAnimation(UPDATE_PERIOD / 2);
            updateLabels(plantVoltage,gridVoltage);
            int curPointIndex=line.getValues().size() - FUTURE_POINTS_COUNT;
            PointValue curPoint=line.getValues().get(curPointIndex);
            curPoint.set(curPoint.getX(),plantVoltage);
            for (            PointValue point : line.getValues()) {
              point.setTarget(point.getX() - 1,point.getY());
              minValue=Math.min(minValue,point.getY());
              maxValue=Math.max(maxValue,point.getY());
            }
            if (line.getValues().size() == (POINTS_COUNT + PAST_POINTS_COUNT + FUTURE_POINTS_COUNT)) {
              line.getValues().remove(0);
            }
            line.getValues().add(new PointValue(POINTS_COUNT + FUTURE_POINTS_COUNT,plantVoltage));
            lineChart.startDataAnimation(UPDATE_PERIOD / 2);
            lineChart.getChartRenderer().setMinViewportYValue(minValue - Y_AXIS_MIN_MAX_DIV);
            lineChart.getChartRenderer().setMaxViewportYValue(maxValue + Y_AXIS_MIN_MAX_DIV);
          }
        }
);
      }
    }
  }
);
  updateThread.start();
  return rootView;
}
