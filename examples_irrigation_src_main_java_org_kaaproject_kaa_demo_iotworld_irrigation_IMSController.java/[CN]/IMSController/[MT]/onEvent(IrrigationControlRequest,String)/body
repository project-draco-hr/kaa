{
  LOG.info("Received irrigation control request from {}",source);
  long newInterval=TimeUnit.SECONDS.toMillis(request.getIrrigationIntervalSec());
  long timeToIrregation=0;
  if (scheduledFuture != null && !scheduledFuture.isCancelled() || scheduledFuture.isDone()) {
    timeToIrregation=scheduledFuture.getDelay(TimeUnit.MILLISECONDS);
  }
  long newWateringTime=stateHolder.getLastWateringTime() + newInterval;
  if (newWateringTime > timeToIrregation) {
    stateHolder.setTimeToNextIrrigationMs(newWateringTime - System.currentTimeMillis());
  }
 else {
    stateHolder.setTimeToNextIrrigationMs(newInterval);
    stateHolder.setLastWateringTime(System.currentTimeMillis());
  }
  stateHolder.setIrrigationIntervalSec(TimeUnit.MILLISECONDS.toSeconds(newInterval));
  scheduleTimeTask(stateHolder.getTimeToNextIrrigationMs(),stateHolder.getIrrigationIntervalMs(),new IrrigationCallbackImpl());
  if (LOG.isTraceEnabled()) {
    LOG.trace("Sending events for {} endpoints",Arrays.toString(subscriptedDevices.toArray()));
  }
 else {
    LOG.info("Sending events for {} endpoints",subscriptedDevices.size());
  }
  IrrigationStatusUpdate update=stateHolder.getIrrigationStatusUpdate();
  for (  String device : subscriptedDevices) {
    if (source.equals(device)) {
      IrrigationStatus status=update.getStatus();
      IrrigationStatus copy=new IrrigationStatus();
      copy.setIgnoreIrrigationIntervalUpdate(true);
      copy.setIsIrrigation(status.getIsIrrigation());
      copy.setIrrigationIntervalSec(status.getIrrigationIntervalSec());
      copy.setMonthlySpentWater(status.getMonthlySpentWater());
      copy.setRemainingWater(status.getRemainingWater());
      copy.setTimeToNextIrrigationMs(status.getTimeToNextIrrigationMs());
      LOG.debug("Sending irrigation status update {} for sending control request device",copy);
      irrigation.sendEvent(new IrrigationStatusUpdate(copy),source);
    }
 else {
      LOG.debug("Sending irrigation status update {}",update);
      irrigation.sendEvent(update,device);
    }
  }
}
