{
  if (stopped) {
    return;
  }
  Cell nextCell;
  boolean nextCellIsSame=false;
  do {
    if (tryExit()) {
      return;
    }
    boolean deadEnd=context.getCell().isDeadEnd();
    nextCell=context.getExitSearchAlgorithm().getNextCell(context.getLabyrinth(),context.getCell(),robotPositions);
    if (!deadEnd && context.getCell().isDeadEnd()) {
      context.getEventManager().reportLocation(context.getCell());
    }
    nextCellIsSame=nextCell.equals(context.getCell());
    if (nextCellIsSame) {
      try {
        LOG.warn("Calculated next cell is same {}, sleeping 200 ms",nextCell);
        Thread.sleep(200);
      }
 catch (      InterruptedException e) {
      }
    }
  }
 while (nextCellIsSame && !stopped);
  if (stopped) {
    return;
  }
  final Cell next=nextCell;
  LOG.info("Calculated next target cell {}",next);
  context.getEventManager().requestMove(next,new MoveEventListener(){
    @Override public void onMoveForbidden(    Reason reason){
      LOG.debug("Move forbidden to {}",next);
      tryMove();
    }
    @Override public void onMoveAllowed(){
      LOG.debug("Move allowed to {}",next);
      context.getRobotManager().move(next,new RobotMoveListener(){
        @Override public void onMoveSuccess(){
          context.setCell(robot.getPosition());
          context.getEventManager().reportLocation(context.getCell());
          scan();
        }
        @Override public void onMoveFailure(){
          LOG.warn("Move failure!");
        }
      }
);
    }
  }
);
}
