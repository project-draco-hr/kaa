{
  validateCTLSchemaObject(unSavedSchema);
  LOG.info("---> Session: {}, this: {}",schemaMetaInfoDao.getSession().hashCode(),this.hashCode());
  CTLSchemaMetaInfoDto metaInfo=unSavedSchema.getMetaInfo();
  CTLSchemaScopeDto currentScope=null;
  if (isBlank(unSavedSchema.getTenantId())) {
    currentScope=SYSTEM;
  }
 else   if (!isBlank(unSavedSchema.getTenantId())) {
    currentScope=TENANT;
  }
 else   if (!isBlank(unSavedSchema.getAppId())) {
    currentScope=APPLICATION;
  }
  metaInfo.setSchemaScopeDto(currentScope);
  CTLSchemaDto dto;
synchronized (this) {
    CTLSchemaMetaInfo uniqueMetaInfo;
    try {
      uniqueMetaInfo=schemaMetaInfoDao.save(new CTLSchemaMetaInfo(metaInfo));
    }
 catch (    Exception e) {
      LOG.warn("---> Got rollback during save metainfo object.");
      uniqueMetaInfo=schemaMetaInfoDao.findByFqnAndVersion(metaInfo.getFqn(),metaInfo.getVersion());
    }
    schemaMetaInfoDao.lockRequest(lo).setScope(true).lock(uniqueMetaInfo);
switch (uniqueMetaInfo.getSchemaScopeDto()) {
case SYSTEM:
      throw new RuntimeException("Disable to store system ctl schema with same fqn and version.");
case TENANT:
    if (currentScope == SYSTEM) {
      throw new RuntimeException("Disable to store system ctl schema. Tenant's scope schema already exists with the same fqn and version.");
    }
  break;
case APPLICATION:
break;
default :
break;
}
CTLSchema ctlSchema=new CTLSchema(unSavedSchema);
ctlSchema.setMetaInfo(uniqueMetaInfo);
schemaMetaInfoDao.incrementCount(uniqueMetaInfo);
dto=getDto(ctlSchemaDao.save(ctlSchema,true));
LOG.info("---> end trans");
}
return dto;
}
